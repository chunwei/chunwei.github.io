任务驱动上下文对话引擎说明
------------------------

+ version
  - 20171114, zzhang: 初版 

+ 设计目的

  - 模拟真实世界中进行的多轮对话情况
  - 分离场景编写人员与场景背景逻辑支持人员的工作. 比如角色扮演中前台对话与后台执行数据的分离.
  - 最大化利用现有语法系统. 所以编写的对话编译是建立在语法编译的基础上的, 如果使用现有的语法, 这些语法也需要一起编译.
  
+ 定义场景

  - 术语定义  
    - 对话在用户(user)和机器(bot)之间进行, 用户输入语句input, 机器输出语句output
    - 含有若干input/output的对话源文件称为流文件(flow)
    
  - 场景定义  
    任何可以输入或输出语句的集合都可以叫做场景. 场景可以是单句场景, 也可以是组合场景.
    
  - 单句场景定义  
    单句场景格式: 方向标识符 [场景条件] 场景语法 [场景动作], 其中:
    * 方向标识符: ">" 表示输入, "<" 表示输出
    * 场景条件和场景动作是可选的动作定义(参见动作定义), 场景条件是该单句场景的执行条件, 场景动作是场景执行后采取的动作.
    * 对输入语句而言, 场景语法的格式跟现有语法系统的格式一致, 在其中可以直接引用现有的语法. 例如:
      ```
      > "我想要" math.数字 "个苹果"
      ```
    * 对输出语句而言, 场景语法是一个表达式, 定义了输出的文本内容, 在其中可以引用场景变量(参见场景变量). 例如:
      ```
      < "好, 给你" exp "个苹果"
      ```
      也可以直接调用一段程序的输出来作为输出语句的输出. 例如:
      ```
      < { return "hello" }
      ```

  - 动作定义  
    场景的动作可以包含一个或多个动作单元, 每个动作单元可以是一个tag标注, 也可以是一段由"{}"括起来的代码.
    这些单元之间是AND关系. 
    
    * tag标注由"@"符号后面跟一个变量名称组成, 中间可以插入一个"!"符号表示反转.
      变量名称可由字母, 数字, 汉字或下划线组成; 其中数字不可以出现在开头.
      例如:
      ```
      < @!完成作业 "好好做作业"
      > "我作业做完了" @完成作业
      < @完成作业 @收拾好书包 {weather!="raining"} "出去玩吧"
      ```
      tag标注也可以引用场景变量, 其中boolean变量判真的条件是true, String变量判真的条件是非空.
    * 代码动作是由"{}"括起来的一段groovy代码. 代码中可以使用场景变量, 参见场景变量.
      groovy代码中可以使用外部类, 这是与外部代码互动的接口. 例如:
      ```
      < { new com.rsvp.Greetings().response("hello") }
      ```

  - 组合场景定义  
    一个或多个场景(可以是单个场景, 也可以是嵌套的子场景)可以组成组合场景. 目前有两类组合场景, 顺序场景和乱序场景.
    (场景中以"#"结尾的语句表示场景结束, 参见场景入口与结束)
    * 顺序场景是由"()"括起来的子场景集合, 这些子场景必须按顺序执行. 例如:
      ```
      (
        < "准备好了吗? "
        > "准备好了"
        < "我们出发吧"
      )
      ``` 
    * 乱序场景是由"[]"括起来的子场景集合, 满足执行条件的子场景都可以被执行, 目前选择执行的是第一个满足条件的子场景. 例如:
      ```
      [
        < @!time "什么时候出发?"
        < @!address "去哪儿?"
        < @time @address "咱们" time "出发去" address
      ]
      ```
    * 当对话只包含一人一句的时候, 这样的语句对可以采用"=>"的简写形式. 例如:
      ```
      < "什么时候出发?" => time
      ```
      简写形式支持嵌套, 输入和输出轮流进行. 例如:
      ```
      < "准备好了吗?"
      => "准备好了"
      => "我们出发吧"
      ```
      简写形式也支持子场景. 例如:
      ```
      < "准备好了吗?" => [
        > "没呢, 等我一下" {ready = false}
        > "准备好了" {ready = true}
      ]
      ```

  - 场景的命名空间, 命名和调用  
    * 在flow文件的开始可以用namespace定义文件中场景的命名空间:
      ```
      namespace 角色扮演
      ```
    * 每个场景(单个场景或组合场景)的方向标识符前可以用名称加":"进行命名:
      ```
      answer: [
        > "没呢, 等我一下" {ready = false}
        > "准备好了" {ready = true}
      ]
      ```
      并通过"命名空间.场景名"进行调用(同一命名空间可以省略命名空间):
      ```
      < "准备好了吗?" => call answer
      ```
    * 对子场景的call调用可以额外指定参数, 在调用的场景名后添加"()"来列出参数列表,
      表示调用完成后需要保留的变量,
      这些变量可以在父场景的继续运行中使用. 变量也支持重命名. 例如:
      ```
      (
        < "准备好了吗?"
        > call answer(confirmed=ready)
        < @confirmed "OK"
      )
      ```
      在指定参数并且没有二义的情况下, 有时也可以省略call, 直接用"场景名(参数)"来调用.
  
+ 运行场景

  - 场景运行  
    用户所写的flow文件集合经过编译后可以进行运行. 场景之间经过嵌套或调用关联在一起,
    场景运行的具体过程为:
    1. 从根场景(也可指定场景)开始
    2. 寻找当前状态下满足条件的下一条input/output
    3. 进行输入解析或输出生成
    4. 执行选定场景的后续动作, 改变当前状态
    5. 如果当前场景结束了, 就回到父场景
    6. 继续下一条
    
  - 场景入口与结束  
    在场景运行中, 下一条可能的语句是从当前场景中选取的. 如果是顺序场景, 则是下一条语句.
    如果是乱序场景, 每条语句都可能, 只要他是满足条件的input(或对应的output).
    如果这条语句是子场景的调用, 则子场景的所有入口语句都会被尝试选取.
    
    场景的语句入口是通过在方向标识符前添加一个">"来表示的. 场景的结束语句是通过在语句后面添加一个"#"来表示的. 例如:
    ```
    [
      << "准备好了吗"
      << "你好了吗"
      << call other_greetings
      > "没呢, 等我一下" {ready = false} #
      > "准备好了" {ready = true} #
    ]
    ```
    场景的入口和结束指定规则如下(根据这些规则可以减少不必要的入口/结束语句标注):
    * 如果只有一条语句, 这条语句是入口语句也是结束语句
    * "=>"标注的简写形式前句是入口语句, 后句是结束语句
    * 顺序场景的第一条语句是入口语句, 最后一条语句是结束语句
    * 乱序场景可以指定入口语句, 如果没有指定入口语句, 所有语句都是入口语句
    * 乱序场景如果所有语句都是input, 或所有语句都是output, 这些语句都是结束语句, 否则显式指定结束语句

+ 场景变量
